diff 8154ecb3fc6c1265e0d5c0ab4288ad514463924d uncommitted
--- a/vdir.c
+++ b/vdir.c
@@ -29,10 +29,10 @@
 
 enum
 {
-	Mdelete,
 	Mrename,
+	Mdelete,
 };
-char *menu2str[] = { "delete", "rename", nil };
+char *menu2str[] = { "rename", "delete", nil };
 Menu menu2 = { menu2str };
 
 const char ellipsis[] = "â€¦";
@@ -252,7 +252,7 @@
 {
 	char cmd[300];
 
-	snprint(cmd, sizeof cmd, "rm -r %s/%s", path, name);
+	snprint(cmd, sizeof cmd, "rm %s/%s", path, name);
 	if(doexec(cmd) < 0)
 		showerrstr("Cannot remove file/directory");
 	else
@@ -272,7 +272,7 @@
 }
 
 int
-plumbfile(char *path, char *name)
+plumbfile(char *path, char *name, int isdir)
 {
 	char *f;
 	int e;
@@ -279,9 +279,12 @@
 
 	f = smprint("%s/%s", path, name);
 	e = access(f, 0)==0;
-	if(e)
-		plumbsendtext(plumbfd, "vdir", nil, path, name);
-	else{
+	if(e){
+	    if(isdir)
+			plumbsendtext(plumbfd, "vdir", nil, nil, f);
+		else
+			plumbsendtext(plumbfd, "vdir", nil, path, name);
+	}else{
 		alert("Error", "File does not exist anymore", nil, mctl, kctl);
 		loaddirs();
 		redraw();
@@ -587,17 +590,51 @@
 	else if(m.buttons == 0)
 		scrolling = 0;
 
-	if(m.buttons&1){
+	if(m.buttons&1 && oldbuttons == 0){
 		if(scrolling){
 			dy = 1+nlines*((double)(m.xy.y - scrollr.min.y)/Dy(scrollr));
 			scrollup(dy);
+		}else if(ptinrect(m.xy, homer)){
+			cd(nil);
+			redraw();
+		}else if(ptinrect(m.xy, upr)){
+			up();
+			redraw();
+		}else if(ptinrect(m.xy, cdr)){
+			m.xy = cept("Go to directory");
+			if(enter("Go to directory", buf, sizeof buf, mctl, kctl, nil)>0){
+				cd(buf);
+				redraw();
+			}
+		}else if(ptinrect(m.xy, newdirr)){
+			m.xy = cept("Create directory");
+			if(enter("Create directory", buf, sizeof buf, mctl, kctl, nil)>0){
+				mkdir(buf);
+				redraw();
+			}
+		}else if(ptinrect(m.xy, newfiler)){
+			m.xy = cept("Create file");
+			if(enter("Create file", buf, sizeof buf, mctl, kctl, nil)>0){
+				touch(buf);
+				redraw();
+			}
+		}else if(ptinrect(m.xy, viewr)){
+			n = indexat(m.xy);
+			if(n==-1)
+				return;
+			d = dirs[offset+n];
+			if(d.qid.type & QTDIR){
+				cd(d.name);
+				redraw();
+			}
 		}
-	}else if(m.buttons&2){
+	}else if(m.buttons&2 && oldbuttons == 0){
 		if(ptinrect(m.xy, viewr)){
 			n = indexat(m.xy);
 			if(n==-1)
 				return;
 			d = dirs[offset+n];
+			menu2.lasthit = 0;
 			switch(menuhit(2, mctl, &menu2, nil)){
 			case Mdelete:
 				rm(d.name);
@@ -620,44 +657,15 @@
 		if(scrolling){
 			dy = 1+nlines*((double)(m.xy.y - scrollr.min.y)/Dy(scrollr));
 			scrolldown(dy);
-		}else if(ptinrect(m.xy, homer)){
-			cd(nil);
-			redraw();
-		}else if(ptinrect(m.xy, upr)){
-			up();
-			redraw();
-		}else if(ptinrect(m.xy, cdr)){
-			m.xy = cept("Go to directory");
-			if(enter("Go to directory", buf, sizeof buf, mctl, kctl, nil)>0){
-				cd(buf);
-				redraw();
-			}
 		}else if(ptinrect(m.xy, pathr)){
-			plumbsendtext(plumbfd, "vdir", nil, nil, path);
-		}else if(ptinrect(m.xy, newdirr)){
-			m.xy = cept("Create directory");
-			if(enter("Create directory", buf, sizeof buf, mctl, kctl, nil)>0){
-				mkdir(buf);
-				redraw();
-			}
-		}else if(ptinrect(m.xy, newfiler)){
-			m.xy = cept("Create file");
-			if(enter("Create file", buf, sizeof buf, mctl, kctl, nil)>0){
-				touch(buf);
-				redraw();
-			}
+			plumbsendtext(plumbfd, "vdirw", nil, nil, path);
 		}else if(ptinrect(m.xy, viewr)){
 			n = indexat(m.xy);
 			if(n==-1)
 				return;
 			d = dirs[offset+n];
-			if(d.qid.type & QTDIR){
-				cd(d.name);
-				redraw();
-			}else{
-				if(plumbfile(path, d.name))
-					flash(n);
-			}
+			if(plumbfile(path, d.name, d.qid.type & QTDIR))
+				flash(n);
 		}
 	}else if(m.buttons&8)
 		scrollup(Slowscroll);
